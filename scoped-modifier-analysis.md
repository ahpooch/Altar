# Анализ модификатора `scoped` в Jinja2 и Altar

## Что такое `scoped` в Jinja2?

В Jinja2 блоки по умолчанию **НЕ имеют доступа** к переменным внешней области видимости (например, переменным цикла). Это сделано намеренно для предотвращения проблем при наследовании шаблонов.

### Пример проблемы в Jinja2 (без scoped):

```jinja2
{% for item in seq %}
    <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}
```

В Jinja2 этот код выведет **пустые** `<li>` элементы, потому что переменная `item` недоступна внутри блока.

### Решение в Jinja2 - модификатор `scoped`:

```jinja2
{% for item in seq %}
    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>
{% endfor %}
```

Модификатор `scoped` **разрешает** блоку доступ к переменным внешней области видимости.

## Поведение в Altar

### Текущая реализация:

В Altar блоки внутри циклов **УЖЕ имеют доступ** к переменным цикла по умолчанию:

```altar
{% for item in items %}
<li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}
```

**Результат:**
```html
<li>apple</li>
<li>banana</li>
<li>cherry</li>
```

### Почему это работает?

**Причина:** PowerShell использует динамическую область видимости.

Когда компилятор генерирует код для цикла:

```powershell
foreach ($item in $LoopItems) {
    # Создание loop переменной
    $loop = [PSCustomObject]@{ ... }
    
    # Код блока генерируется здесь же, в той же области видимости
    $output.Append($item.ToString()) | Out-Null
}
```

Переменная `$item` создается в области видимости `foreach` и автоматически доступна во всех вложенных блоках кода, включая код, сгенерированный для `{% block %}`.

## Сравнение

| Аспект | Jinja2 (без scoped) | Jinja2 (с scoped) | Altar (текущее) |
|--------|---------------------|-------------------|-----------------|
| Доступ к переменным цикла в блоке | ❌ Нет | ✅ Да | ✅ Да (по умолчанию) |
| Синтаксис | `{% block name %}` | `{% block name scoped %}` | `{% block name %}` |
| Изоляция блоков | ✅ Да | ❌ Нет | ❌ Нет |

## Рекомендации

### Вариант 1: Оставить как есть
- **Плюсы:** Проще в использовании, не требует дополнительного синтаксиса
- **Минусы:** Отличается от поведения Jinja2 по умолчанию

### Вариант 2: Реализовать полную совместимость с Jinja2
- Изменить поведение по умолчанию: блоки НЕ имеют доступа к внешним переменным
- Добавить поддержку модификатора `scoped` для разрешения доступа
- **Плюсы:** Полная совместимость с Jinja2
- **Минусы:** Breaking change, усложнение реализации

### Вариант 3: Добавить поддержку синтаксиса `scoped` (без изменения поведения)
- Парсер принимает модификатор `scoped`, но игнорирует его
- Поведение остается прежним (доступ всегда разрешен)
- **Плюсы:** Синтаксическая совместимость, шаблоны Jinja2 со `scoped` будут работать
- **Минусы:** Семантическая несовместимость (но это уже есть)

## Текущий статус

Модификатор `scoped` **НЕ реализован** в Altar. Парсер выдает ошибку при попытке использовать этот синтаксис.

Рекомендуется **Вариант 3**: добавить поддержку синтаксиса для совместимости, сохранив текущее поведение.
